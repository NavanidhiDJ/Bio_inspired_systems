import numpy as np

# -----------------------------
# 1. Define Problem: Neural Network (XOR classification)
# -----------------------------
# Dataset (XOR problem)
X = np.array([[0,0],
              [0,1],
              [1,0],
              [1,1]])
y = np.array([[0],
              [1],
              [1],
              [0]])

# Neural network architecture: 2 -> 4 -> 1
input_size = 2
hidden_size = 4
output_size = 1

# -----------------------------
# Helper functions
# -----------------------------
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def forward_pass(weights, X):
    """
    Forward pass of NN with given weights.
    weights = flattened array containing all weights and biases
    """
    # Unpack weights
    w1_size = input_size * hidden_size
    b1_size = hidden_size
    w2_size = hidden_size * output_size
    b2_size = output_size

    w1 = weights[:w1_size].reshape(input_size, hidden_size)
    b1 = weights[w1_size:w1_size+b1_size].reshape(1, hidden_size)
    w2 = weights[w1_size+b1_size:w1_size+b1_size+w2_size].reshape(hidden_size, output_size)
    b2 = weights[-b2_size:].reshape(1, output_size)

    # Forward pass
    hidden = sigmoid(np.dot(X, w1) + b1)
    output = sigmoid(np.dot(hidden, w2) + b2)
    return output

def fitness_function(weights):
    """ Fitness = accuracy of predictions """
    predictions = forward_pass(weights, X)
    predicted_labels = (predictions > 0.5).astype(int)
    accuracy = np.mean(predicted_labels == y)
    return accuracy

# -----------------------------
# 2. Initialize GA Parameters
# -----------------------------
pop_size = 50       # population size
n_generations = 200 # number of generations
mutation_rate = 0.1
crossover_rate = 0.8

# Total number of weights in NN
n_weights = input_size*hidden_size + hidden_size + hidden_size*output_size + output_size

# -----------------------------
# 3. Create Initial Population
# -----------------------------
population = np.random.uniform(-1, 1, (pop_size, n_weights))

# -----------------------------
# GA Operators
# -----------------------------
def selection(population, fitness):
    """ Tournament selection """
    idx1, idx2 = np.random.randint(0, len(population), 2)
    return population[idx1] if fitness[idx1] > fitness[idx2] else population[idx2]

def crossover(parent1, parent2):
    """ Single-point crossover """
    if np.random.rand() < crossover_rate:
        point = np.random.randint(1, n_weights-1)
        child1 = np.concatenate([parent1[:point], parent2[point:]])
        child2 = np.concatenate([parent2[:point], parent1[point:]])
        return child1, child2
    else:
        return parent1.copy(), parent2.copy()

def mutate(individual):
    """ Random mutation """
    for i in range(len(individual)):
        if np.random.rand() < mutation_rate:
            individual[i] += np.random.normal(0, 0.5)  # small perturbation
    return individual

# -----------------------------
# 4â€“8. GA Main Loop
# -----------------------------
best_fitness_history = []
for generation in range(n_generations):
    # Evaluate fitness
    fitness = np.array([fitness_function(ind) for ind in population])

    # Track best solution
    best_idx = np.argmax(fitness)
    best_fitness = fitness[best_idx]
    best_fitness_history.append(best_fitness)

    if generation % 20 == 0:
        print(f"Gen {generation}: Best Fitness = {best_fitness:.4f}")

    # New population
    new_population = []
    while len(new_population) < pop_size:
        parent1 = selection(population, fitness)
        parent2 = selection(population, fitness)
        child1, child2 = crossover(parent1, parent2)
        new_population.append(mutate(child1))
        new_population.append(mutate(child2))
    population = np.array(new_population[:pop_size])

# -----------------------------
# 9. Output Best Solution
# -----------------------------
fitness = np.array([fitness_function(ind) for ind in population])
best_idx = np.argmax(fitness)
best_weights = population[best_idx]
print("\nBest solution found:")
print("Accuracy:", fitness[best_idx])

# Test the best weights on XOR
preds = forward_pass(best_weights, X)
print("Predictions:", (preds > 0.5).astype(int).flatten())
print("Expected   :", y.flatten())
